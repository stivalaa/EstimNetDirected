/*****************************************************************************
 * 
 * File:    equilibriumExpectation.c
 * Author:  Alex Stivala, Maksym Byshkin
 * Created: October 2017
 *
 * Equilibirum expectation algorithm for ERGM estimation of directed graphs.
 * In fact there are two (very similar) algorithms: Algorithm S for
 * simulated networks (i.e. those generated by an ERGM process) and Algorithm
 * EE for empirical networks. Algorithm S is used to get starting parameters
 * for Algorithm EE.
 *
 * The main difference between the algorithms is that Algorithm S does 
 * not actually perform the MCMC moves in the sampler, while algorithm EE does,
 * and Algoritm EE accumulates the change dzA values, which are zeroed
 * every iteration in Algorithm S (see reference below).
 *
 * Reference for ths implementation is
 *
 *   Stivala, A., Robins, G., & Lomi, A. (2019). Exponential random graph
 *   model parameter estimation for very large directed networks.
 *   arXiv preprint arXiv:1904.08063. https://arxiv.org/abs/1904.08063
 *
 * Reference for the algorithm (originally for undirected networks) is
 *
 *   Byshkin M, Stivala A, Mira A, Robins G, Lomi A 2018 "Fast
 *   maximum likelihood estimation via equilibrium expectation for
 *   large network data". Scientific Reports 8:11509
 *   doi:10.1038/s41598-018-29725-8
 *
 * And for the Borisenko update step in the EE algorithm is:
 *
 *   Borisenko, A., Byshkin, M., & Lomi, A. (2019). A Simple Algorithm
 *   for Scalable Monte Carlo Inference. arXiv preprint arXiv:1901.00533.
 *
 * Reference for citation ERGM (cERGM) estimation is:
 *
 *   Schmid, C. S., Chen, T. H. Y., & Desmarais, B. A. (2021). 
 *   Generative Dynamics of Supreme Court Citations:
 *   Analysis with a New Statistical Network Model. arXiv preprint
 *   arXiv:2101.07197.
 *
 *
 * Preprocessor defines used:
 *
 *    TWOPATH_LOOKUP      - use two-path lookup tables (arrays by default)
 *    TWOPATH_HASHTABLES  - use hash tables (only if TWOPATH_LOOKUP defined)
 *
 *
 ****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <limits.h>
#include "utils.h"
#include "graph.h"
#include "loadGraph.h"
#include "basicSampler.h"
#include "ifdSampler.h"
#include "tntSampler.h"
#include "equilibriumExpectation.h"

/*****************************************************************************
 *
 * externally visible functions
 *
 ****************************************************************************/


/*
 * Algorithm S for estimating parameters of digraph generated by ERGM,
 * and estimating the derivatives for use in Algorithm EE.
 *
 * Parameters:
 *   g      - digraph object.
 *   n      - number of parameters (length of theta vector = total
 *            length of all change statistics functions)
 *   n_attr - number of attribute change stats funcs
 *   n_dyadic -number of dyadic covariate change stats funcs
 *   n_attr_interaction - number of attribute interaction change stats funcs
 *   change_stats_funcs - array of pointers to change statistics functions
 *                        length is n - n_attr - n_dyadic - n_attr_interacion
 *   lambda_values      - array of lambda values for change stats funcs
 *                        same length as change_stats_funcs
 *   attr_change_stats_funcs - array of pointers to change statistics functions
 *                             length is n_attr
 *   dyadic_change_stats_funcs - array of pointers to dyadic change stats funcs
 *                             length is n_dyadic
 *   attr_interaction_change_stats_funcs - array of pointers to attribute
 *                           interaction (pair) change statistics functions.
 *                           length is n_attr_interaction.
 *   attr_indices   - array of n_attr attribute indices (index into g->binattr
 *                    or g->catattr) corresponding to attr_change_stats_funcs
 *                    E.g. for Sender effect on the first binary attribute,
 *                    attr_indices[x] = 0 and attr_change_stats_funcs[x] =
 *                    changeSender
 *   exponent_values - array of exponent values for attr change stats funcs
 *                     length is n_attr
 *   attr_interaction_pair_indices - array of n_attr_interaction pairs
 *                          of attribute inidices similar to above but
 *                          for attr_interaction_change_setats_funcs which
 *                          requires pairs of indices.
 *   M1          - Number of iterations of Algorithm S
 *   sampler_m   - Number of proposals (sampling iterations) [per step of Alg.S]
 *   ACA         -  multiplier of da to get K1A step size multiplier 
 *   theta  - (Out) array of n parameter values corresponding to
 *                  change stats funcs. Allocated by caller.
 *   Dmean - (Out) array of n derivative estimate values corresponding to theta.
 *                 Allocated by caller
 *   theta_outfile - open (write) file to write theta values to
 *   useIFDsampler - use IFD sampler instead of basic sampler
 *   ifd_K         - constant for multipliying IFD auxiliary parameter
 *                   (only used if useIFDsampler is True).
 *   useConditionalEstimation - do conditional estimation of snowball sample
 *   forbidReciprocity - if True do not allow reciprocated arcs.
 *   useTNTsampler     - use TNT sampler not IFD or basic.
 *   citationERGM      - use cERGM (citation ERGM) estimation conditional
 *                       on term (time period)
 *   allowLoops        - allow self-edges (loops)
 *
 * Return value:
 *   None.
 *
 * The theta and Dmean array parameters, which must be allocted by caller,
 * are set to the parameter estimtes and derivative estimtes respectively.
 */

void algorithm_S(graph_t *g, uint_t n, uint_t n_attr, uint_t n_dyadic,
                 uint_t n_attr_interaction,
                 change_stats_func_t *change_stats_funcs[],
                 double lambda_values[],
                 attr_change_stats_func_t *attr_change_stats_funcs[],
                 dyadic_change_stats_func_t *dyadic_change_stats_funcs[],
                 attr_interaction_change_stats_func_t
                                  *attr_interaction_change_stats_funcs[],
                 uint_t attr_indices[],
                 double exponent_values[],
                 uint_pair_t attr_interaction_pair_indices[],
                 uint_t M1,
                 uint_t sampler_m,
                 double ACA,
                 double theta[],
                 double Dmean[],
                 FILE * theta_outfile,
                 bool useIFDsampler,
                 double ifd_K,
                 bool useConditionalEstimation,
                 bool forbidReciprocity, bool useTNTsampler, bool citationERGM,
                 bool allowLoops)
{
  uint_t t, l;
  double acceptance_rate;
  double *addChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *delChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *sumChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *dzA = (double *)safe_malloc(n*sizeof(double));
  double *da = (double *)safe_malloc(n*sizeof(double));
  double *theta_step = (double *)safe_malloc(n*sizeof(double));  
  /* 1/D0 is squared derivatives */  
  double *D0 = (double *)safe_calloc(n, sizeof(double));
  double  dzArc; /* (unused) required only for IFD sampler */
  double  arc_correction_val; /* only used for IFD sampler */
  double ifd_aux_param = 0; /* auxiliary parameter for IFD sampler */

  if (useIFDsampler)
    arc_correction_val = arcCorrection(g, useConditionalEstimation,
                                       citationERGM, forbidReciprocity,
                                       allowLoops);

  for (l = 0; l < n; l++)
    theta[l] = 0;
  for (t = 0; t < M1; t++) {
    fprintf(theta_outfile, "%d ", t-M1);
    if (useIFDsampler) {
      acceptance_rate = ifdSampler(g, n, n_attr, n_dyadic,
                                   n_attr_interaction,
                                   change_stats_funcs,
                                   lambda_values,
                                   attr_change_stats_funcs,
                                   dyadic_change_stats_funcs,
                                   attr_interaction_change_stats_funcs,
                                   attr_indices,
                                   exponent_values,
                                   attr_interaction_pair_indices,
                                   theta,
                                   addChangeStats, delChangeStats, sampler_m,
                                   FALSE,
                                   ifd_K, &dzArc, &ifd_aux_param,
                                   useConditionalEstimation,
                                   forbidReciprocity, citationERGM,
                                   allowLoops);
      /* Arc parameter for IFD is auxiliary parameter adjusted by correction value */
      fprintf(theta_outfile, "%g ", ifd_aux_param - arc_correction_val);
    } else if (useTNTsampler) {
      acceptance_rate = tntSampler(g, n, n_attr, n_dyadic,
                                   n_attr_interaction,
                                   change_stats_funcs,
                                   lambda_values,
                                   attr_change_stats_funcs,
                                   dyadic_change_stats_funcs,
                                   attr_interaction_change_stats_funcs,
                                   attr_indices,
                                   exponent_values,
                                   attr_interaction_pair_indices,
                                   theta,
                                   addChangeStats, delChangeStats, sampler_m,
                                   FALSE, useConditionalEstimation,
                                   forbidReciprocity, citationERGM,
                                   allowLoops);
      
    } else {
      acceptance_rate = basicSampler(g, n, n_attr, n_dyadic,
                                     n_attr_interaction,
                                     change_stats_funcs,
                                     lambda_values,
                                     attr_change_stats_funcs,
                                     dyadic_change_stats_funcs,
                                     attr_interaction_change_stats_funcs,
                                     attr_indices,
                                     exponent_values,
                                     attr_interaction_pair_indices,
                                     theta,
                                     addChangeStats, delChangeStats, sampler_m,
                                     FALSE, useConditionalEstimation,
                                     forbidReciprocity, citationERGM,
                                     allowLoops);
    }
    for (l = 0; l < n; l++) {
      dzA[l] = delChangeStats[l] - addChangeStats[l];
      ALGS_DEBUG_PRINT(("addChangeStats[%u] = %g delChangeStats[%u] = %g\n",
                        l, addChangeStats[l], l, delChangeStats[l]));
      sumChangeStats[l] = addChangeStats[l] + delChangeStats[l];
      //The expectation of square of change of statistics is computed
      //It approximates the deriviative with respect to parameter
      D0[l] += dzA[l]*dzA[l];
      da[l] = 0;
      if (sumChangeStats[l] < 0 || sumChangeStats[l] > 0)
        da[l] = ACA / (sumChangeStats[l]*sumChangeStats[l]);
      theta_step[l] = (dzA[l] < 0 ? -1 : 1) * da[l] * dzA[l]*dzA[l];
      theta[l] += theta_step[l];
      fprintf(theta_outfile, "%g ", theta[l]);
    }
    fprintf(theta_outfile, "%g\n", acceptance_rate);
  }
  for (l = 0; l < n; l++)
    Dmean[l] = sampler_m / D0[l];
  
  free(D0);
  free(theta_step);
  free(da);
  free(dzA);
  free(sumChangeStats);
  free(delChangeStats);
  free(addChangeStats);
}


/*
 * Algorithm EE for estimating ERGM parameters of arbitrary digraph.
 *
 * Parameters:
 *   g      - digraph object. NB modifed by sampler.
 *   n      - number of parameters (length of theta vector = 
 *            total number of change stats funcs)
 *   n_attr - number of attribute change stats functions
 *   n_dyadic -number of dyadic covariate change stats funcs
 *   n_attr_interaction - number of attribute interaction change stats funcs
 *   change_stats_funcs - array of pointers to change statistics functions
 *                        length is n - n_attr - n_dyadic - n_attr_interaction
 *   lambda_values      - array of lambda values for change stats funcs
 *                        same length as change_stats_funcs
 *   attr_change_stats_funcs - array of pointers to change statistics functions
 *                              length is n_attr
 *   dyadic_change_stats_funcs - array of pointers to dyadic change stats funcs
 *                             length is n_dyadic
 *   attr_interaction_change_stats_funcs - array of pointers to attribute
 *                           interaction (pair) change statistics functions.
 *                           length is n_attr_interaction.
 *   attr_indices   - array of n_attr attribute indices (index into g->binattr
 *                    or g->catattr) corresponding to attr_change_stats_funcs
 *                    E.g. for Sender effect on the first binary attribute,
 *                    attr_indices[x] = 0 and attr_change_stats_funcs[x] =
 *                    changeSender
 *   exponent_values - array of exponent values for attr change stats funcs
 *                     length is n_attr
 *   attr_interaction_pair_indices - array of n_attr_interaction pairs
 *                          of attribute inidices similar to above but
 *                          for attr_interaction_change_setats_funcs which
 *                          requires pairs of indices.
 *   Mouter     - Number of iterations of Algorithm EE (outer loop)
 *   Minner     - Number of iterations of Algorithm EE (inner loop)
 *   sampler_m  - Number of proposals (sampling iterations) 
 *                 [per step of Alg.EE]
 *   ACA        - multiplier of D0 to get K_A step size multiplier
 *                (not used if useBorisenkUpdate is True)
 *   compC      - multiplier of sd(theta)/mean(theta) to limit
 *                  theta variance 
 *                (not used if useBorisenkoUpdate is True)
 *   D0     -   array of n derivative estimate values corresponding to theta,
 *              results of algorithm_S()
 *                (not used if useBorisenkoUpdate is True)
 *   theta  - (In/Out) array of n parameter values corresponding to
 *                  change stats funcs. Input starting values (from 
 *                  alorithm_S(), output EE values.
 *  theta_outfile - open (write) file to write theta values to.
 *  dzA_outfile   - open (write) file to write dzA values to.
 *  outputAllSteps - if True, output theta and dzA values every iteration,
 *                   otherwise only on every outer iteration.
 *  useIFDsampler  - if True, use IFD sampler instead of basic sampler.
 *  ifd_K          - constant for multipliying IFD auxiliary parameter step
 *                   size (only used if useIFDsampler is True).
 *  useConditionalEstimation - if True, do conditional estimation for snowball
 *                             network samples.
 *  forbidReciprocity - if True do not allow reciprocated arcs.
 *  useBorisenkoUpdate- if True use the Borisenko et al. (2019) theta update
 *  learningRate      - learning rate (step size multiplier) if 
 *                      useBorisenkoUpdate is True
 *  minTheta          - small positive constant c in Borisenko update step
 *                      to avoid zero step at zero parameter values if
 *                      useBorisenkoUpdate is true.
 *  useTNTsampler     - use TNT sampler not IFD or basic.
 *
 *  citationERGM      - use cERGM (citation ERGM) estimation conditional
 *                       on term (time period)
 *  allowLoops        - allow self-edges (loops)
 *
 * Return value:
 *   None.
 *
 * The theta and Dmean array parameters, which must be allocted by caller,
 * are set to the parameter estimtes and derivative estimtes respectively.
 */
void algorithm_EE(graph_t *g, uint_t n, uint_t n_attr, uint_t n_dyadic,
                  uint_t n_attr_interaction,
                  change_stats_func_t *change_stats_funcs[],
                  double lambda_values[],
                  attr_change_stats_func_t *attr_change_stats_funcs[],
                  dyadic_change_stats_func_t *dyadic_change_stats_funcs[],
                  attr_interaction_change_stats_func_t
                                   *attr_interaction_change_stats_funcs[],
                  uint_t attr_indices[],
                  double exponent_values[],
                  uint_pair_t attr_interaction_pair_indices[],
                  uint_t Mouter, uint_t Minner,
                  uint_t sampler_m,
                  double ACA, double compC,
                  double D0[],
                  double theta[],
                  FILE *theta_outfile, FILE *dzA_outfile, bool outputAllSteps,
                  bool useIFDsampler, double ifd_K,
                  bool useConditionalEstimation,
                  bool forbidReciprocity, bool useBorisenkoUpdate,
                  double learningRate, double minTheta,
                  bool useTNTsampler, bool citationERGM, bool allowLoops)
{
  uint_t touter, tinner, l, t = 0;
  double acceptance_rate;
  double theta_mean, theta_sd;
  double *addChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *delChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *sumChangeStats = (double *)safe_malloc(n*sizeof(double));
  double *da = (double *)safe_malloc(n*sizeof(double));
  double *theta_step = (double *)safe_malloc(n*sizeof(double));
  /* dzA is only zeroed here, and accumulates in the loop */
  double *dzA = (double *)safe_calloc(n, sizeof(double));
  /* each element of thetamatrix is an array of Minner theta[l]
     values, one for each of the 0 <= l < n elements of theta, used to
     accumulate them to compute mean and sd over innter iterations for
     each outer iteration */
  double **thetamatrix = (double **)safe_malloc(n*sizeof(double *));
  double arc_correction_val; /* only used for IFD sampler */
  double dzArc; /* only used for IFD sampler */
  double ifd_aux_param = 0; /* auxiliary parameter for IFD sampler */

  if (useIFDsampler) 
    arc_correction_val = arcCorrection(g, useConditionalEstimation,
                                       citationERGM, forbidReciprocity,
                                       allowLoops);

  for (l = 0; l < n; l++)
    thetamatrix[l] = (double *)safe_malloc(Minner*sizeof(double));

  for (touter = 0; touter < Mouter; touter++) {
    for (tinner = 0; tinner < Minner; tinner++) {
      if (outputAllSteps || tinner == 0) {
        fprintf(theta_outfile, "%u ", t);
        fprintf(dzA_outfile, "%u ", t);
#ifdef TWOPATH_HASHTABLES
        if (g->is_directed) {
          MEMUSAGE_DEBUG_PRINT(("MixTwoPath hash table has %u entries (%f MB)\n",
                                HASH_COUNT(g->mixTwoPathHashTab),
                                (double)(HASH_COUNT(g->mixTwoPathHashTab)*2*
                                         sizeof(twopath_record_t))/(1024*1024)));
          MEMUSAGE_DEBUG_PRINT(("InTwoPath hash table has %u entries (%f MB)\n",
                                HASH_COUNT(g->inTwoPathHashTab),
                                (double)(HASH_COUNT(g->inTwoPathHashTab)*
                                         (sizeof(twopath_record_t)))/(1024*1024)));
          MEMUSAGE_DEBUG_PRINT(("OutTwoPath hash table has %u entries (%f MB)\n",
                                HASH_COUNT(g->outTwoPathHashTab),
                                (double)(HASH_COUNT(g->outTwoPathHashTab)*2*
                                         sizeof(twopath_record_t))/(1024*1024)));
        }
#endif /* DEBUG_MEMUSAGE */
      }
      if (useIFDsampler) {
        acceptance_rate = ifdSampler(g, n, n_attr, n_dyadic, n_attr_interaction,
                                     change_stats_funcs,
                                     lambda_values,
                                     attr_change_stats_funcs,
                                     dyadic_change_stats_funcs,
                                     attr_interaction_change_stats_funcs,
                                     attr_indices,
                                     exponent_values,
                                     attr_interaction_pair_indices,
                                     theta,
                                     addChangeStats, delChangeStats, sampler_m,
                                     TRUE, /*Algorithm EE actually does moves */
                                     ifd_K, &dzArc, &ifd_aux_param,
                                     useConditionalEstimation,
                                     forbidReciprocity, citationERGM,
                                     allowLoops);
        if (useIFDsampler && (outputAllSteps || tinner == 0)) {
          /* difference of Arc statistic for IFD sampler is just Ndel-Nadd */
          fprintf(dzA_outfile, "%g ", dzArc);
          /* Arc parameter for IFD sampler is auxiliary parameter adjusted */
          fprintf(theta_outfile, "%g ", ifd_aux_param - arc_correction_val);
        }
      } else if (useTNTsampler) {
        acceptance_rate = tntSampler(g, n, n_attr, n_dyadic,
                                     n_attr_interaction,
                                     change_stats_funcs,
                                     lambda_values,
                                     attr_change_stats_funcs,
                                     dyadic_change_stats_funcs,
                                     attr_interaction_change_stats_funcs,
                                     attr_indices,
                                     exponent_values,
                                     attr_interaction_pair_indices,
                                     theta,
                                     addChangeStats, delChangeStats,
                                     sampler_m,
                                     TRUE,/*Algorithm EE actually does moves*/
                                     useConditionalEstimation,
                                     forbidReciprocity, citationERGM,
                                     allowLoops);
      } else {
        acceptance_rate = basicSampler(g, n, n_attr, n_dyadic,
                                       n_attr_interaction,
                                       change_stats_funcs,
                                       lambda_values,
                                       attr_change_stats_funcs,
                                       dyadic_change_stats_funcs,
                                       attr_interaction_change_stats_funcs,
                                       attr_indices,
                                       exponent_values,
                                       attr_interaction_pair_indices,
                                       theta,
                                       addChangeStats, delChangeStats,
                                       sampler_m,
                                       TRUE,/*Algorithm EE actually does moves*/
                                       useConditionalEstimation,
                                       forbidReciprocity, citationERGM,
                                       allowLoops);
      }
      for (l = 0; l < n; l++) {
        dzA[l] += addChangeStats[l] - delChangeStats[l]; /* dzA accumulates */
        ALGEE_DEBUG_PRINT(("addChangeStats[%u] = %g delChangeStats[%u] = %g\n",
                          l, addChangeStats[l], l, delChangeStats[l]));
        if (useBorisenkoUpdate) {
          theta_step[l] = (dzA[l] < 0 ? 1 : -1) *
            learningRate * MAX(fabs(theta[l]), minTheta);
        } else {
          da[l] = D0[l] * ACA;
          theta_step[l] = (dzA[l] < 0 ? 1 : -1) * da[l] * dzA[l]*dzA[l];
        }
        theta[l] += theta_step[l];
        if (outputAllSteps || tinner == 0) {
          fprintf(dzA_outfile, "%g ", dzA[l]);
          fprintf(theta_outfile, "%g ", theta[l]);
        }
        thetamatrix[l][tinner] = theta[l];
      }
      if (outputAllSteps || tinner == 0) {      
        fprintf(theta_outfile, "%g\n", acceptance_rate);
        fprintf(dzA_outfile, "\n");
      }
      t++;
    }
    if (!useBorisenkoUpdate) {
      /* get mean and sd of each theta value over inner loop iterations
         and adjust D0 to limit variance of theta (see S.I.) */
      for (l = 0; l < n; l++) {
        theta_mean = mean_and_sd(thetamatrix[l], Minner, &theta_sd);
        /* force minimum magnitude to stop theta sticking at zero */
        /* TODO 0.1 in next two lines was changed in an earlier commit
           from another value with no explanation. It should be made a
           parameter setting instead, or at least a named constant;
           in fact it should be the new parameter minTheta */
        if (fabs(theta_mean) < 0.1)
          theta_mean = 0.1;
        /* theta_sd is a standard deviation so must be non-negative */
        assert(theta_sd >= 0);
        if (theta_sd > 1e-10) { /* TODO make this a parameter */
          /* as per email from Max 21 July 2018, only adjust D0 this way
           * if sd(theta) is large enough */
          D0[l] *= sqrt(compC / (theta_sd / fabs(theta_mean)));
        }
      }
    }
    fflush(dzA_outfile);
    fflush(theta_outfile); 
  }
  for (l = 0; l < n; l++)
    free(thetamatrix[l]);
  free(thetamatrix);
  free(theta_step);
  free(da);
  free(dzA);
  free(sumChangeStats);
  free(delChangeStats);
  free(addChangeStats);
}



/*
 * Estimate ERGM parameters by using Algorithm S followed by Algorithm EE.
 *
 * Parameters:
 *   g      - digraph object. Modifed if performMove is true.
 *   n      - number of parameters (length of theta vector and total
 *            number of change statistics functions)
 *   n_attr - number of attribute change statistics functions
 *   n_dyadic -number of dyadic covariate change stats funcs
 *   n_attr_interaction - number of attribute interaction change stats funcs
 *   change_stats_funcs - array of pointers to change statistics functions
 *                        length is n - n_attr - n_dyadic - n_attr_interaction
 *   lambda_values      - array of lambda values for change stats funcs
 *                        same length as change_stats_funcs
 *   attr_change_stats_funcs - array of pointers to change statistics functions
 *                             length is n_attr
 *   dyadic_change_stats_funcs - array of pointers to dyadic change stats funcs
 *                             length is n_dyadic
 *   attr_interaction_change_stats_funcs - array of pointers to attribute
 *                           interaction (pair) change statistics functions.
 *                           length is n_attr_interaction.
 *   attr_indices   - array of n_attr attribute indices (index into g->binattr
 *                    or g->catattr) corresponding to attr_change_stats_funcs
 *                    E.g. for Sender effect on the first binary attribute,
 *                    attr_indices[x] = 0 and attr_change_stats_funcs[x] =
 *                    changeSender
 *   exponent_values - array of exponent values for attr change stats funcs
 *                     length is n_attr
 *   attr_interaction_pair_indices - array of n_attr_interaction pairs
 *                          of attribute inidices similar to above but
 *                          for attr_interaction_change_setats_funcs which
 *                          requires pairs of indices.
 *   sampler_m      - sampler iterations (per algorithm step)
 *   M1_steps       - Steps of Algorithm 1 
 *   Mouter         - outer iteration of Algorithm EE
 *   Msteps         - number of inner steps of Algorithm EE
 *   ACA_S          -  multiplier of da to get K1A step size multiplier 
 *   ACA_EE         - multiplier of D0 to get K_A step size multiplier
 *   compC      - multiplier of sd(theta)/mean(theta) to limit
 *                   theta variance 
 *   theta  - (Out) array of n parameter values corresponding to
 *                  change stats funcs. Allocated by caller.
 *   tasknum - task number (MPI rank)
 *   theta_outfile - open (write) file to write theta values to
 *   dzA_outfile   - open (write) file to write dzA values to
 *   outputAllSteps - in Algorithm EE, output theta and dzA values on every
 *                    iteration, not just every outer iteration.
 *   useIFDsampler  - if true, use the IFD sampler instead of the basic 
 *                    sampler
 *   ifd_K          - consant for multiplying IFD auxiliary parameter
 *                    (only used if useIFDsampler is True).
 *   useConditionalEstimation - if True, do conditional estimation of 
 *                              snowball network samples.
 *   forbidReciprocity - if True, constrain ERGM sampling so that reciprocated
 *                       arcs are not allowed to be created (so estimation
 *                       is conditional on no reciprocated arcs, should have
 *                       none in input observed graph).
 *  useBorisenkoUpdate- if True use the Borisenko et al. (2019) theta update
 *  learningRate      - learning rate (step size multiplier) if 
 *                      useBorisenkoUpdate is True
 *  minTheta          - small positive constant c in Borisenko update step
 *                      to avoid zero step at zero parameter values if
 *                      useBorisenkoUpdate is true.
 *  useTNTsampler     - use TNT sampler not IFD or basic.
 *  citationERGM      - use cERGM (citation ERGM) estimation conditional
 *                      on term (time period)
 *  allowLoops        - allow self-edges (loops)
 *
 * Return value:
 *   Nonzero on error, 0 if OK.
 *
 * The theta and Dmean array parameters, which must be allocted by caller,
 * are set to the parameter estimtes and derivative estimtes respectively.
 */
int ee_estimate(graph_t *g, uint_t n, uint_t n_attr, uint_t n_dyadic,
                uint_t n_attr_interaction,
                change_stats_func_t *change_stats_funcs[],
                double lambda_values[],
                attr_change_stats_func_t *attr_change_stats_funcs[],
                dyadic_change_stats_func_t *dyadic_change_stats_funcs[],
                attr_interaction_change_stats_func_t
                                 *attr_interaction_change_stats_funcs[],
                uint_t attr_indices[],
                double exponent_values[],
                uint_pair_t attr_interaction_pair_indices[],
                uint_t sampler_m, uint_t M1_steps, uint_t Mouter,
                uint_t Msteps, double ACA_S, double ACA_EE, double compC,
                double theta[], uint_t tasknum,
                FILE *theta_outfile, FILE *dzA_outfile, bool outputAllSteps,
                bool useIFDsampler, double ifd_K,
                bool useConditionalEstimation,
                bool forbidReciprocity, bool useBorisenkoUpdate,
                double learningRate, double minTheta,
                bool useTNTsampler, bool citationERGM, bool allowLoops)
{
  struct timeval start_timeval, end_timeval, elapsed_timeval;
  int            etime;
  uint_t         i;
  int            errcode = 0;

  /*array of n derivative estimate values corresponding to theta. */  
  double *Dmean = (double *)safe_malloc(n*sizeof(double));

  assert(!(useIFDsampler && useTNTsampler));
  assert(!(citationERGM && useConditionalEstimation));
    
  if (useBorisenkoUpdate) {
    printf("task %u:  ACA_S = %g, Borisenko update learningRate = %g, "
           "minTheta = %g, samplerSteps = %u, "
           "Ssteps = %u, EEsteps = %u, EEinnerSteps = %u\n", tasknum,
           ACA_S, learningRate, minTheta, sampler_m, M1_steps, Mouter, Msteps);
  } else {
    printf("task %u: ACA_S = %g, ACA_EE = %g, compC = %g, samplerSteps = %u, "
           "Ssteps = %u, EEsteps = %u, EEinnerSteps = %u\n", tasknum,
           ACA_S, ACA_EE, compC, sampler_m, M1_steps, Mouter, Msteps);
  }
    
  if (useIFDsampler)
    printf("task %u: IFD sampler ifd_K = %g, arcCorrection = %g\n",
           tasknum, ifd_K, arcCorrection(g, useConditionalEstimation,
                                         citationERGM, forbidReciprocity,
                                         allowLoops));
  else if (useTNTsampler)
    printf("task %u: TNT sampler\n", tasknum);

  if (useConditionalEstimation)
    printf("task %u: Doing conditional estimation of snowball sample\n",
      tasknum);

  if (forbidReciprocity)
    printf("task %u: estimation is conditional on no reciprocated arcs\n",
      tasknum);

  if (citationERGM)
    printf("task %u: citation ERGM (cERGM) estimation conditional on term\n",
           tasknum);

  if (allowLoops)
    printf("task %u: allowing self-edges (loops)\n", tasknum);

  /* steps of algorithm S (M1_steps */
  /*uint_t M1 = (uint_t)(M1_steps *g->num_nodes / sampler_m);*/
  /* just as for Msteps below, no longer scale by network size
   * as that results in excessive values for very large networks */
  uint_t M1 = M1_steps;

  /* inner steps of Algorithm EE */
  /*uint_t M = (uint_t)(Msteps *g->num_nodes / sampler_m);*/
  /* as per email from Max 20 July 2018, better to have this as constant
   * rather than scaled by network size */
  uint_t M = Msteps;
  


  printf("task %u: M1 = %u, Mouter = %u, M = %u\n", tasknum, M1, Mouter, M);


  printf("task %u: running Algorithm S...\n", tasknum);
  gettimeofday(&start_timeval, NULL);

  algorithm_S(g, n, n_attr, n_dyadic, n_attr_interaction, change_stats_funcs,
              lambda_values,
              attr_change_stats_funcs, dyadic_change_stats_funcs,
              attr_interaction_change_stats_funcs,
              attr_indices, exponent_values, attr_interaction_pair_indices,
              M1, sampler_m, ACA_S, theta, Dmean, theta_outfile, useIFDsampler,
              ifd_K, useConditionalEstimation, forbidReciprocity,
              useTNTsampler, citationERGM, allowLoops);

  gettimeofday(&end_timeval, NULL);
  timeval_subtract(&elapsed_timeval, &end_timeval, &start_timeval);
  etime = 1000 * elapsed_timeval.tv_sec + elapsed_timeval.tv_usec/1000;
  printf("task %u: Algorithm S took %.2f s\n", tasknum, (double)etime/1000);
  printf("task %u: theta = ", tasknum);
  for (i = 0; i < n; i++) 
    printf("%g ", theta[i]);
  printf("\ntask %u: Dmean = ", tasknum);
  for (i = 0; i < n; i++) 
    printf("%g ", Dmean[i]);
  printf("\n");
  fflush(theta_outfile);

  if (!useBorisenkoUpdate) {
    /* D0 not used for Borisenko et al. 2019 update theta algorithm in EE */
    printf("\ntask %u: initial value of D0 for algorithm_EE = ", tasknum);
    for (i = 0; i < n; i++) {
      printf("%g ", Dmean[i]);
    }
    printf("\n");
  }

  /* but it is still useful to test for possible model degeneracy */
  for (i = 0; i < n; i++) {
    if (isinf(Dmean[i])) {
      fprintf(stderr, "task %u: WARNING: D0 is NaN for parameter %d, "
              "model may be degenerate, not continuing this run\n", tasknum, i);
      errcode = 1;
    }
  }

  if (errcode == 0) {
    printf("task %u: running Algorithm EE...\n", tasknum);
    gettimeofday(&start_timeval, NULL);

    algorithm_EE(g, n, n_attr, n_dyadic, n_attr_interaction,
                 change_stats_funcs, lambda_values,
                 attr_change_stats_funcs, dyadic_change_stats_funcs,
                 attr_interaction_change_stats_funcs,
                 attr_indices, exponent_values, attr_interaction_pair_indices,
                 Mouter, M, sampler_m, ACA_EE, compC,
                 Dmean, theta, theta_outfile, dzA_outfile, outputAllSteps,
                 useIFDsampler, ifd_K, useConditionalEstimation,
                 forbidReciprocity, useBorisenkoUpdate, learningRate,
                 minTheta, useTNTsampler, citationERGM, allowLoops);

    gettimeofday(&end_timeval, NULL);
    timeval_subtract(&elapsed_timeval, &end_timeval, &start_timeval);
    etime = 1000 * elapsed_timeval.tv_sec + elapsed_timeval.tv_usec/1000;
    printf("task %u: Algorithm EE took %.2f s\n", tasknum, (double)etime/1000);
  }
  free(Dmean);
  return errcode;
}

/*
 * Do estimation using the S and EE algorithms for digraph read from
 * Pajek format.
 *
 * Parameters:
 *   config - (in/out)configuration settings structure  - this is modified
 *            by calling build_attr_indices_from_names() etc.
 *   tasknum - task number (MPI rank)
 *
 * Return value:
 *    0 if OK else -ve value for error.
 */
int do_estimation(estim_config_t * config, uint_t tasknum)
{
  struct timeval start_timeval, end_timeval, elapsed_timeval;
  int            etime;
  FILE          *arclist_file;
  graph_t     *g;
  uint_t         num_nodes, num_A_nodes;
  uint_t         i;
  FILE          *theta_outfile;
  FILE          *dzA_outfile;
  FILE          *sim_outfile;
  FILE          *obs_stats_outfile = NULL;
  char           theta_outfilename[PATH_MAX+1];
  char           dzA_outfilename[PATH_MAX+1];
  char           sim_outfilename[PATH_MAX+1];
  char           obs_stats_outfilename[PATH_MAX+1];
  char           suffix[16]; /* only has to be large enough for "_xx.txt" 
                                where xx is tasknum */
  uint_t         n_struct, n_attr, n_dyadic, n_attr_interaction, num_param;
  double        *theta;
  double        *graphStats = NULL;
#define HEADER_MAX 65536
  char fileheader[HEADER_MAX];
  /* only compute the observed sufficient statistics in task 0 */
  bool          computeStats = config->computeStats && tasknum == 0;
  bool          first_header_field = TRUE;
  uint_t        loop_count = 0;
  const char   *arc_param_str = NULL;

  if (!config->arclist_filename) {
    fprintf(stderr, "ERROR: no arclistFile specified.\n");
    return -1;
  }
  if (!(arclist_file = fopen(config->arclist_filename, "r"))) {
    fprintf(stderr, "error opening file %s (%s)\n", 
            config->arclist_filename, strerror(errno));
    return -1;
  }
  if (!config->isBipartite) {
    num_nodes = get_num_vertices_from_arclist_file(arclist_file);/* closes file */
  } else {
    /* bipartite (two-mode) network */
    if (config->allowLoops) {
      fprintf(stderr, "ERROR: cannot allow loops in bipartite graph\n");
      return -1;
    }
    if (config->isDirected) {
      fprintf(stderr, "ERROR: directed bipartite graphs not suported\n");
      return -1;
    }
    if (config->useConditionalEstimation) {
      fprintf(stderr, "ERROR: conditional estimation with bipartite graphs not supported\n");
      return -1;
    }
    
    get_num_vertices_from_bipartite_pajek_file(arclist_file,
                                               &num_nodes,
                                               &num_A_nodes);/* closes file */
  }
  g = allocate_graph(num_nodes, config->isDirected, config->isBipartite,
                     num_A_nodes);

  if (check_param_network_type(&config->param_config, g)) {
    fprintf(stderr, "ERROR: parameter not compatible with network type\n");
    return -1;
  }

  arc_param_str = g->is_directed ? ARC_PARAM_STR : EDGE_PARAM_STR;

  /* Ensure that for the IFD sampler there is no Arc parameter included 
     as the IFD sampler computes this itself from the auxiliary parameter.
     If the user includes the Arc (or Edge for undirected) parameter,
     then remove it: its estimated parameter value, computed from the IFD
     sampler auxiliary parameter, will be output anyway. */
  if (config->useIFDsampler) {
    bool found = FALSE;
    for (i = 0; i < config->param_config.num_change_stats_funcs &&
           strcasecmp(config->param_config.param_names[i], arc_param_str) != 0;
         i++)
      /*nothing*/;
    found = i < config->param_config.num_change_stats_funcs;
    if (found) {
      /* remove Arc/Edge parameter by replacing it with last entry
         (which changes nothing if it is the last entry) and
         shrinking lists by one */
      config->param_config.change_stats_funcs[i] = config->param_config.change_stats_funcs[config->param_config.num_change_stats_funcs-1];
      config->param_config.param_names[i] = config->param_config.param_names[config->param_config.num_change_stats_funcs-1];
      config->param_config.param_lambdas[i] = config->param_config.param_lambdas[config->param_config.num_change_stats_funcs-1];
      assert(!config->param_config.param_values);
      config->param_config.change_stats_funcs = (change_stats_func_t **)safe_realloc(config->param_config.change_stats_funcs, (config->param_config.num_change_stats_funcs - 1) * sizeof(change_stats_func_t *));
      config->param_config.param_names = (const char **)safe_realloc(config->param_config.param_names, (config->param_config.num_change_stats_funcs - 1) * sizeof(const char *));
      config->param_config.param_lambdas = (double *)safe_realloc(config->param_config.param_lambdas, (config->param_config.num_change_stats_funcs - 1) * sizeof(double));
      CONFIG_DEBUG_PRINT(("%s parameter (index %u) removed as using IFD sampler.\n", arc_param_str, i));
      config->param_config.num_change_stats_funcs--;
    }
  }
   
  
  if (load_attributes(g, config->binattr_filename,
                       config->catattr_filename,
                      config->contattr_filename,
                      config->setattr_filename)) {
    fprintf(stderr, "ERROR: loading node attributes failed\n");
    return -1;
  }
  

  /* now that we have attributes loaded in g, build the attr_indices
     array in the config struct */
  if (build_attr_indices_from_names(&config->param_config, g) != 0)  {
    fprintf(stderr, "ERROR in attribute parameters\n");
    return -1;
  }
  /* and similary for dyadic covariates */
  if (build_dyadic_indices_from_names(&config->param_config, g, FALSE) != 0)  {
    fprintf(stderr, "ERROR in dyadic covariate parameters\n");
    return -1;
  }
  /* and attribute interaction parameters */
  if (build_attr_interaction_pair_indices_from_names(&config->param_config, g) != 0) {
    fprintf(stderr, "ERROR in attribute interaction parameters\n");
    return -1;
  }

  /* note num_param is computed here as build_dyadic_indices_from_names()
     can decrease config->num_dyadic_change_stats_funcs from its 
     initial value */
  n_struct = config->param_config.num_change_stats_funcs;
  n_attr = config->param_config.num_attr_change_stats_funcs;
  n_dyadic = config->param_config.num_dyadic_change_stats_funcs;
  n_attr_interaction = config->param_config.num_attr_interaction_change_stats_funcs;
  num_param =  n_struct + n_attr + n_dyadic + n_attr_interaction;
    
  theta = (double *)safe_malloc(num_param*sizeof(double));

  /* Only one sampler can be used (only binary attributes in config,
     did not include multiple options (maybe should) */
  if (config->useIFDsampler && config->useTNTsampler) {
    fprintf(stderr, "ERROR: Only one of the useIFDsampler and"
             " useTNTsampler options may be used\n");
    return -1;
  }
  
  if (computeStats) {
    /* allocate change statistics array */
    graphStats = (double *)safe_malloc(num_param * sizeof(double));
    /* set values of graph stats for empty graph; most (but not all) are zero */
    empty_graph_stats(g, num_param, n_attr, n_dyadic,
                      n_attr_interaction,
                      config->param_config.change_stats_funcs,
                      config->param_config.param_lambdas,
                      config->param_config.attr_change_stats_funcs,
                      config->param_config.dyadic_change_stats_funcs,
                      config->param_config.attr_interaction_change_stats_funcs,
                      config->param_config.attr_indices,
                      config->param_config.attr_param_exponents,
                      config->param_config.attr_interaction_pair_indices,
                      graphStats);
  }
  
  if (!(arclist_file = fopen(config->arclist_filename, "r"))) {
    fprintf(stderr, "error opening file %s (%s)\n", 
            config->arclist_filename, strerror(errno));
    return -1;
  }
  gettimeofday(&start_timeval, NULL);
#ifdef TWOPATH_LOOKUP
  printf("loading arc list from %s and building two-path matrices",
         config->arclist_filename);
#else
  printf("loading arc list from %s", config->arclist_filename);
#endif /*TWOPATH_LOOKUP*/
  if (computeStats)
    printf(" and computing observed statistics");
  printf("..\n");
  g = load_graph_from_arclist_file(arclist_file, g,
                                     computeStats,
                                     num_param,
                                     n_attr, n_dyadic, n_attr_interaction,
                                     config->param_config.change_stats_funcs,
                                     config->param_config.param_lambdas,
                                     config->param_config.attr_change_stats_funcs,
                                     config->param_config.dyadic_change_stats_funcs,
                                     config->param_config.attr_interaction_change_stats_funcs,
                                     config->param_config.attr_indices,
                                     config->param_config.attr_param_exponents,
                                     config->param_config.attr_interaction_pair_indices,
                                     graphStats, theta);
  gettimeofday(&end_timeval, NULL);
  timeval_subtract(&elapsed_timeval, &end_timeval, &start_timeval);
  etime = 1000 * elapsed_timeval.tv_sec + elapsed_timeval.tv_usec/1000;
  printf("%.2f s\n", (double)etime/1000);
#ifdef DEBUG_DIGRAPH
  dump_graph_arclist(g);
#endif /*DEBUG_DIGRAPH*/

  if (config->zone_filename) {
    if (add_snowball_zones_to_graph(g, config->zone_filename)) {
      fprintf(stderr, "ERROR: reading snowball sampling zones from %s failed\n",
              config->zone_filename);
      return -1;
    }
#ifdef DEBUG_SNOWBALL
    dump_zone_info(g);
#endif /* DEBUG_SNOWBALL */
  }

  if (config->term_filename) {
    if (add_cergm_terms_to_digraph(g, config->term_filename)) {
      fprintf(stderr, "ERROR: reading cERGM terms from %s failed\n",
              config->term_filename);
      return -1;
    }
#ifdef DEBUG_CERGM
    dump_term_info(g);
#endif /* DEBUG_CERGM */
  }

  if (computeStats) {
    printf("Observed statistics:");
    for (i = 0; i < num_param; i++)
      printf(" %g", graphStats[i]);
    printf("\n");
  }

  
  /* Open the output files (separate ones for each task), for writing */
  strncpy(theta_outfilename, config->theta_file_prefix,
          sizeof(theta_outfilename)-1);
  strncpy(dzA_outfilename, config->dzA_file_prefix,
          sizeof(dzA_outfilename)-1);
  sprintf(suffix, "_%d.txt", config->outputFileSuffixBase + tasknum);
  strncat(theta_outfilename, suffix, sizeof(theta_outfilename) - 1 -
          strlen(suffix));
  strncat(dzA_outfilename, suffix, sizeof(dzA_outfilename) - 1 -
          strlen(suffix));
  if (!(theta_outfile = fopen(theta_outfilename, "w"))) {
    fprintf(stderr, "ERROR: task %d could not open file %s for writing "
            "(%s)\n", tasknum, theta_outfilename, strerror(errno));
    return -1;
  }
  if (computeStats) {
    strncpy(obs_stats_outfilename, config->obs_stats_file_prefix,
            sizeof(obs_stats_outfilename)-1);
    strncat(obs_stats_outfilename, suffix,
            sizeof(obs_stats_outfilename) - 1 - strlen(suffix));
    if (!(obs_stats_outfile = fopen(obs_stats_outfilename, "w"))) {
      fprintf(stderr, "ERROR: task %d could not open file %s for writing "
              "(%s)\n", tasknum, obs_stats_outfilename, strerror(errno));
      return -1;
    }
  }

  arc_param_str = g->is_directed ? ARC_PARAM_STR : EDGE_PARAM_STR;

   /* Ensure that for the IFD sampler there is no Arc parameter included 
      as the IFD sampler computes this itself from the auxiliary parameter */
   if (config->useIFDsampler) {
     for (i = 0; i < config->param_config.num_change_stats_funcs; i++) {
       if (strcasecmp(config->param_config.param_names[i], arc_param_str) == 0) {
         fprintf(stderr, 
                 "ERROR: cannot include %s parameter when using IFD sampler.\n"
                 "Either unset useIFDsampler or remove %s from %s.\n",
                 arc_param_str, arc_param_str, STRUCT_PARAMS_STR);
         return -1;
       }
     }
   }

   
  /* Give warnings if parameters set that are not used in selected
     algorithm variation */
  if (!config->useIFDsampler &&
       !DOUBLE_APPROX_EQ(config->ifd_K, DEFAULT_IFD_K)) {
    fprintf(stderr,
            "WARNING: ifd_K is set to %g not default value"
            " but IFD sampler not used\n", config->ifd_K);
  }
  
  if (config->useBorisenkoUpdate) {
    if (!DOUBLE_APPROX_EQ(config->ACA_EE, DEFAULT_ACA_EE)) {
      fprintf(stderr, "WARNING: ACA_EE is set to %g not default value"
              " but useBorisenkoUpdate is True so not used\n", config->ACA_EE);
    }
    if (!DOUBLE_APPROX_EQ(config->compC, DEFAULT_COMPC)) {
      fprintf(stderr, "WARNING: compC is set to %g not default value "
              "but useBorisenkoUpdate is True so not used\n", config->compC);
    }
  } else {
    if (!DOUBLE_APPROX_EQ(config->learningRate, DEFAULT_LEARNING_RATE)) {
      fprintf(stderr, "WARNING: learningRate is set to %g not default value"
              " but useBorisenkoUpdate is not True\n", config->learningRate);
    }
    if (!DOUBLE_APPROX_EQ(config->minTheta, DEFAULT_MIN_THETA)) {
      fprintf(stderr, "WARNING: minTheta is set to %g not default value"
              " but useBorisenkoUpdate is not True\n", config->minTheta);
    }
  }
   
  
  /* Ensure that if conditional estimation is to be used, the snowball
     sampling zone structure was specified */
  if (config->useConditionalEstimation) {
    if (!config->zone_filename) {
      fprintf(stderr,
              "ERROR: conditional estimation requested but no zones specified\n");
       return -1;
     }
     if (g->max_zone < 1) {
       fprintf(stderr,
               "ERROR: conditional estimation requested but only one zone\n");
       return -1;
     }
   }  else {
     if (config->zone_filename)
       fprintf(stderr, "WARNING: snowball sampling zones are specified"
               " but conditional estimation is not being used\n");
   }

   /* Ensure that if citation ERGM cERGM is to be used, the time period (term)
      values were specified, and other requirements for cERGM */
   if (config->citationERGM) {
     if (!config->isDirected) {
       fprintf(stderr, "ERROR: citation ERGM estimation requires directed"
               "graph\n");
       return -1;
     }
     if (config->isBipartite) {
       fprintf(stderr, "ERROR: citation ERGM estimation requires one-mode"
               "graph not two-mode\n");
       return -1;
     }
     if (config->useConditionalEstimation) {
       fprintf(stderr, "ERROR: cannot use both snowball sample conditional"
               " estimation and citation ERGM\n");
         return -1;
     }
     if (!config->term_filename) {
       fprintf(stderr,
           "ERROR: citation ERGM estimation requested but no term file\n");
       return -1;
     }
     if (g->max_term < 1) {
       fprintf(stderr,
               "ERROR: citation ERGM estimation requested but only one time period\n");
       return -1;
     }
   }
   
  if (config->allowLoops) {
    if (!config->isDirected) {
      fprintf(stderr, "ERROR: cannot use allowLoops with undirected graph\n");
      return -1;
    }
    if (config->useConditionalEstimation) {
      fprintf(stderr, "ERROR: cannot use allowLoops in conditional estimation\n");
      return -1;
    }
    if (config->citationERGM) {
      fprintf(stderr, "ERROR: cannot use allowLoops with citation ERGM\n");
      return -1;
    }
  }

   if (config->forbidReciprocity && !config->isDirected) {
     fprintf(stderr, "ERROR: cannot have forbidReciprocity TRUE for "
             "undirected graph\n");
     return -1;
   }
   
  if (tasknum == 0) {
    print_data_summary(g, config->allowLoops);
    loop_count = num_loops(g);
    printf("%s has %u self-edges (loops)\n", 
           g->is_directed ? "Digraph" : "Graph", loop_count);
    if (loop_count > 0) {
      if (!config->allowLoops) {
        fprintf(stderr, "WARNING: graph has self-edges but allowLoops is not true\n");
      }
    }
    print_zone_summary(g);
    print_term_summary(g);
  }
   
  if (!(dzA_outfile = fopen(dzA_outfilename, "w"))) {
    fprintf(stderr, "ERROR: task %d could not open file %s for writing "
            "(%s)\n", tasknum, dzA_outfilename, strerror(errno));
    return -1;
  }
  
  /* write headers for output files */
  if (config->useIFDsampler){/* IFD sampler always computes an Arc parameter */
    snprintf(fileheader+strlen(fileheader), HEADER_MAX,"%s", arc_param_str);
    first_header_field = FALSE;
  }
  for (i = 0; i < config->param_config.num_change_stats_funcs; i++)  {
    if (!first_header_field)
      snprintf(fileheader+strlen(fileheader), HEADER_MAX," ");
    /* Print the lambda (decay) [hyper-]parameter value for parameters which
       use it (i.e. for the "alternating" statistics); it is 0 for those
       for which it is not applicable.
       Format is to put it in parens after the name e.g. AltTwoPathsTD(2.5) */
    if (config->param_config.param_lambdas[i] > 0.0) {
      snprintf(fileheader+strlen(fileheader), HEADER_MAX,"%s(%g)",
               config->param_config.param_names[i],
               config->param_config.param_lambdas[i]);
    } else {
      snprintf(fileheader+strlen(fileheader), HEADER_MAX,"%s",
               config->param_config.param_names[i]);      
    }
    first_header_field = FALSE;
  }
  
  for (i = 0; i < config->param_config.num_attr_change_stats_funcs; i++) {
    if (!first_header_field)
      snprintf(fileheader+strlen(fileheader), HEADER_MAX," ");
    /* print the exponent [hyper-] parameter value for attribute parameters
       which used it; it is negative for those for which it is not applicable.
       Format is to put it in parens after the name and attribute e.g.
       BipartiteNodematchBetaA_gender(0.1) */
    if (config->param_config.attr_param_exponents[i] >= 0.0) {
      snprintf(fileheader+strlen(fileheader), HEADER_MAX, "%s_%s(%g)",
               config->param_config.attr_param_names[i],
               config->param_config.attr_names[i],
               config->param_config.attr_param_exponents[i]);
    } else {
      snprintf(fileheader+strlen(fileheader), HEADER_MAX, "%s_%s",
               config->param_config.attr_param_names[i],
               config->param_config.attr_names[i]);
    }
    first_header_field = FALSE;
  }
  
  for (i = 0; i < config->param_config.num_dyadic_change_stats_funcs; i++) {
    if (!first_header_field)
      snprintf(fileheader+strlen(fileheader), HEADER_MAX," ");
    snprintf(fileheader+strlen(fileheader), HEADER_MAX, "%s",
             config->param_config.dyadic_param_names[i]);
    first_header_field = FALSE;
  }
  
  for (i = 0; i < config->param_config.num_attr_interaction_change_stats_funcs; i++) {
    if (!first_header_field)
      snprintf(fileheader+strlen(fileheader), HEADER_MAX," ");
    snprintf(fileheader+strlen(fileheader), HEADER_MAX, "%s_%s_%s",
             config->param_config.attr_interaction_param_names[i],
             config->param_config.attr_interaction_pair_names[i].first,
             config->param_config.attr_interaction_pair_names[i].second);
    first_header_field = FALSE;
  }
  
  
  fprintf(theta_outfile,  "t %s AcceptanceRate\n", fileheader);
  fprintf(dzA_outfile, "t %s\n", fileheader);

  /* output the observed sufficient statistics if selected */
  if (computeStats) {
    fprintf(obs_stats_outfile, "%s\n", fileheader);
    if (config->useIFDsampler) { /* Arc stat not in array, output separately */
      fprintf(obs_stats_outfile, "%u ", num_arcs_or_edges(g));
    }
    for (i = 0; i < num_param; i++) {
      fprintf(obs_stats_outfile, "%g", graphStats[i]);
      if (i == num_param-1)
        fprintf(obs_stats_outfile, "\n");
      else
        fprintf(obs_stats_outfile, " ");
    }
    fclose(obs_stats_outfile);
  }
  
  ee_estimate(g, num_param, n_attr, n_dyadic, n_attr_interaction,
              config->param_config.change_stats_funcs,
              config->param_config.param_lambdas,
              config->param_config.attr_change_stats_funcs,
              config->param_config.dyadic_change_stats_funcs,
              config->param_config.attr_interaction_change_stats_funcs,
              config->param_config.attr_indices,
              config->param_config.attr_param_exponents,
              config->param_config.attr_interaction_pair_indices,
              config->samplerSteps, config->Ssteps,
              config->EEsteps, config->EEinnerSteps,
              config->ACA_S, config->ACA_EE, config->compC,
              theta, tasknum, theta_outfile, dzA_outfile,
              config->outputAllSteps,
              config->useIFDsampler, config->ifd_K,
              config->useConditionalEstimation,
              config->forbidReciprocity,
              config->useBorisenkoUpdate, config->learningRate,
              config->minTheta, config->useTNTsampler,
              config->citationERGM,
              config->allowLoops);

  fclose(theta_outfile);
  fclose(dzA_outfile);
  if (config->outputSimulatedNetwork) {
    strncpy(sim_outfilename, config->sim_net_file_prefix,
            sizeof(sim_outfilename)-1);
    sprintf(suffix, "_%d.net", config->outputFileSuffixBase + tasknum);
    strncat(sim_outfilename, suffix, sizeof(sim_outfilename) - 1 -
            strlen(suffix));
    sim_outfile = fopen(sim_outfilename, "w");
    write_graph_arclist_to_file(sim_outfile, g);
    fclose(sim_outfile);
  }
  free_graph(g);
  free(theta);
  free(graphStats);
  return 0;
}


